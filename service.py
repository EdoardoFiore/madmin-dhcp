"""
DHCP Module - Service Layer

Business logic for DHCP operations: config generation, lease parsing,
service management, and network interface discovery.
"""
import subprocess
import logging
import re
import ipaddress
from pathlib import Path
from datetime import datetime
from typing import List, Optional, Dict
from jinja2 import Template

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func

from .models import DhcpSubnet, DhcpHost, DhcpOption, DhcpLeaseInfo

logger = logging.getLogger(__name__)

# System paths
DHCPD_CONF_PATH = Path("/etc/dhcp/dhcpd.conf")
DHCPD_DEFAULTS_PATH = Path("/etc/default/isc-dhcp-server")
DHCPD_LEASES_PATH = Path("/var/lib/dhcp/dhcpd.leases")
SERVICE_NAME = "isc-dhcp-server"

# Config template (Jinja2)
DHCPD_CONF_TEMPLATE = Template("""\
# =============================================================
#  DHCP Server Configuration
#  Generated by MADMIN DHCP Module — DO NOT EDIT MANUALLY
#  Generated at: {{ generated_at }}
# =============================================================

# Global settings
authoritative;
log-facility local7;

{% if global_options %}
# Global options
{% for opt in global_options %}
option {{ opt.option_name }} {{ opt.option_value }};
{% endfor %}
{% endif %}

{% for subnet in subnets %}
# --- {{ subnet.name }} ({{ subnet.interface }}) ---
subnet {{ subnet.network_address }} netmask {{ subnet.netmask }} {
    range {{ subnet.range_start }} {{ subnet.range_end }};
    option routers {{ subnet.gateway }};
    option domain-name-servers {{ subnet.dns_servers }};
{% if subnet.domain_name %}
    option domain-name "{{ subnet.domain_name }}";
{% endif %}
    default-lease-time {{ subnet.lease_time }};
    max-lease-time {{ subnet.max_lease_time }};
{% if subnet.options %}

    # Subnet-specific options
{% for opt in subnet.options %}
    option {{ opt.option_name }} {{ opt.option_value }};
{% endfor %}
{% endif %}
{% if subnet.hosts %}

    # Static reservations
{% for host in subnet.hosts %}
    host {{ host.hostname }} {
        hardware ethernet {{ host.mac_address }};
        fixed-address {{ host.ip_address }};
    }
{% endfor %}
{% endif %}
}

{% endfor %}
""")


class DhcpService:
    """Service class for DHCP operations."""

    # --- Network Interface Discovery ---

    def get_physical_interfaces(self) -> List[Dict]:
        """
        List physical network interfaces.
        Returns interfaces suitable for DHCP binding.
        Excludes: lo, wg*, veth*, docker*, br*, virbr*, tun*, tap*
        """
        interfaces = []
        net_dir = Path("/sys/class/net")

        if not net_dir.exists():
            return interfaces

        exclude_prefixes = (
            'lo', 'wg', 'veth', 'docker', 'br-', 'virbr', 'tun', 'tap'
        )

        for iface_dir in sorted(net_dir.iterdir()):
            name = iface_dir.name
            if name.startswith(exclude_prefixes):
                continue

            # Read interface state
            try:
                state = (iface_dir / "operstate").read_text().strip()
            except:
                state = "unknown"

            # Read MAC address
            try:
                mac = (iface_dir / "address").read_text().strip()
            except:
                mac = "unknown"

            # Read IP addresses
            ip_addrs = []
            try:
                result = subprocess.run(
                    ["ip", "-4", "addr", "show", name],
                    capture_output=True, text=True
                )
                for line in result.stdout.split('\n'):
                    match = re.search(r'inet\s+(\S+)', line)
                    if match:
                        ip_addrs.append(match.group(1))
            except:
                pass

            interfaces.append({
                "name": name,
                "state": state,
                "mac": mac,
                "addresses": ip_addrs
            })

        return interfaces

    # --- Config Generation ---

    async def generate_config(self, session: AsyncSession) -> str:
        """
        Generate dhcpd.conf from database state.
        Returns the generated config string.
        """
        # Load enabled subnets with hosts and options
        result = await session.execute(
            select(DhcpSubnet).where(DhcpSubnet.enabled == True)
        )
        subnets = result.scalars().all()

        # Load global options (subnet_id IS NULL)
        result = await session.execute(
            select(DhcpOption).where(DhcpOption.subnet_id == None)
        )
        global_options = result.scalars().all()

        # Prepare subnet data for template
        subnet_data = []
        for subnet in subnets:
            # Load hosts for this subnet
            result = await session.execute(
                select(DhcpHost).where(DhcpHost.subnet_id == subnet.id)
            )
            hosts = result.scalars().all()

            # Load options for this subnet
            result = await session.execute(
                select(DhcpOption).where(DhcpOption.subnet_id == subnet.id)
            )
            options = result.scalars().all()

            # Parse CIDR to get network address and netmask
            try:
                network = ipaddress.IPv4Network(subnet.network, strict=False)
                network_address = str(network.network_address)
                netmask = str(network.netmask)
            except ValueError as e:
                logger.error(f"Invalid network CIDR '{subnet.network}': {e}")
                continue

            subnet_data.append({
                "name": subnet.name,
                "network_address": network_address,
                "netmask": netmask,
                "range_start": subnet.range_start,
                "range_end": subnet.range_end,
                "gateway": subnet.gateway,
                "dns_servers": subnet.dns_servers,
                "domain_name": subnet.domain_name,
                "interface": subnet.interface,
                "lease_time": subnet.lease_time,
                "max_lease_time": subnet.max_lease_time,
                "hosts": hosts,
                "options": options
            })

        # Render template
        config = DHCPD_CONF_TEMPLATE.render(
            generated_at=datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC"),
            global_options=global_options,
            subnets=subnet_data
        )

        return config

    async def write_config(self, session: AsyncSession) -> str:
        """Generate and write config to disk. Returns config string."""
        config = await self.generate_config(session)

        try:
            DHCPD_CONF_PATH.parent.mkdir(parents=True, exist_ok=True)
            DHCPD_CONF_PATH.write_text(config)
            logger.info(f"Wrote DHCP config to {DHCPD_CONF_PATH}")
        except PermissionError:
            raise RuntimeError(f"Permission denied writing to {DHCPD_CONF_PATH}")
        except Exception as e:
            raise RuntimeError(f"Failed to write config: {e}")

        return config

    async def update_interfaces_config(self, session: AsyncSession) -> None:
        """
        Update /etc/default/isc-dhcp-server with the list of interfaces
        that have enabled subnets.
        """
        result = await session.execute(
            select(DhcpSubnet.interface).where(DhcpSubnet.enabled == True).distinct()
        )
        interfaces = [row[0] for row in result.all()]
        interfaces_str = " ".join(sorted(set(interfaces)))

        try:
            content = f'INTERFACESv4="{interfaces_str}"\nINTERFACESv6=""\n'
            DHCPD_DEFAULTS_PATH.write_text(content)
            logger.info(f"Updated DHCP interfaces: {interfaces_str}")
        except PermissionError:
            raise RuntimeError(f"Permission denied writing to {DHCPD_DEFAULTS_PATH}")
        except Exception as e:
            raise RuntimeError(f"Failed to update interfaces config: {e}")

    # --- Config Validation ---

    def validate_config(self) -> tuple:
        """
        Validate dhcpd.conf syntax using dhcpd -t.
        Returns (is_valid, message).
        """
        try:
            result = subprocess.run(
                ["dhcpd", "-t", "-cf", str(DHCPD_CONF_PATH)],
                capture_output=True, text=True, timeout=10
            )
            if result.returncode == 0:
                return True, "Configuration syntax is valid"
            else:
                error_msg = result.stderr.strip() or result.stdout.strip()
                return False, error_msg
        except FileNotFoundError:
            return False, "dhcpd command not found"
        except subprocess.TimeoutExpired:
            return False, "Validation timed out"
        except Exception as e:
            return False, str(e)

    # --- Service Management ---

    def get_service_status(self) -> Dict:
        """Get isc-dhcp-server service status."""
        status = {
            "running": False,
            "enabled": False,
            "uptime": None
        }

        try:
            # Check if running
            result = subprocess.run(
                ["systemctl", "is-active", SERVICE_NAME],
                capture_output=True, text=True
            )
            status["running"] = result.stdout.strip() == "active"

            # Check if enabled
            result = subprocess.run(
                ["systemctl", "is-enabled", SERVICE_NAME],
                capture_output=True, text=True
            )
            status["enabled"] = result.stdout.strip() == "enabled"

            # Get uptime if running
            if status["running"]:
                result = subprocess.run(
                    ["systemctl", "show", SERVICE_NAME,
                     "--property=ActiveEnterTimestamp"],
                    capture_output=True, text=True
                )
                timestamp_str = result.stdout.strip().split("=", 1)
                if len(timestamp_str) > 1 and timestamp_str[1]:
                    status["uptime"] = timestamp_str[1]

        except Exception as e:
            logger.error(f"Error checking service status: {e}")

        return status

    def start_service(self) -> tuple:
        """Start isc-dhcp-server. Returns (success, message)."""
        try:
            result = subprocess.run(
                ["systemctl", "start", SERVICE_NAME],
                capture_output=True, text=True, timeout=15
            )
            if result.returncode == 0:
                return True, "Service started"
            else:
                return False, result.stderr.strip() or "Failed to start"
        except Exception as e:
            return False, str(e)

    def stop_service(self) -> tuple:
        """Stop isc-dhcp-server. Returns (success, message)."""
        try:
            result = subprocess.run(
                ["systemctl", "stop", SERVICE_NAME],
                capture_output=True, text=True, timeout=15
            )
            if result.returncode == 0:
                return True, "Service stopped"
            else:
                return False, result.stderr.strip() or "Failed to stop"
        except Exception as e:
            return False, str(e)

    def restart_service(self) -> tuple:
        """Restart isc-dhcp-server. Returns (success, message)."""
        try:
            result = subprocess.run(
                ["systemctl", "restart", SERVICE_NAME],
                capture_output=True, text=True, timeout=15
            )
            if result.returncode == 0:
                return True, "Service restarted"
            else:
                return False, result.stderr.strip() or "Failed to restart"
        except Exception as e:
            return False, str(e)

    async def apply_config(self, session: AsyncSession) -> tuple:
        """
        Full apply workflow: generate → validate → update interfaces → restart.
        Returns (success, message).
        """
        try:
            # 1. Generate and write config
            await self.write_config(session)

            # 2. Update interfaces file
            await self.update_interfaces_config(session)

            # 3. Validate config
            valid, msg = self.validate_config()
            if not valid:
                return False, f"Config validation failed: {msg}"

            # 4. Restart service
            success, msg = self.restart_service()
            if not success:
                return False, f"Service restart failed: {msg}"

            return True, "Configuration applied and service restarted"

        except Exception as e:
            return False, str(e)

    # --- Lease Parsing ---

    def parse_leases(self) -> List[DhcpLeaseInfo]:
        """
        Parse /var/lib/dhcp/dhcpd.leases file.
        Returns list of active leases.
        """
        leases = []

        if not DHCPD_LEASES_PATH.exists():
            return leases

        try:
            content = DHCPD_LEASES_PATH.read_text()
        except Exception as e:
            logger.error(f"Failed to read leases file: {e}")
            return leases

        # Parse lease blocks
        lease_pattern = re.compile(
            r'lease\s+(\S+)\s*\{(.*?)\}',
            re.DOTALL
        )

        # Track latest lease per IP (file has history, last entry wins)
        lease_map = {}

        for match in lease_pattern.finditer(content):
            ip = match.group(1)
            block = match.group(2)

            lease = DhcpLeaseInfo(ip_address=ip)

            # Parse fields
            starts_match = re.search(
                r'starts\s+\d+\s+(\d{4}/\d{2}/\d{2}\s+\d{2}:\d{2}:\d{2})',
                block
            )
            if starts_match:
                lease.starts = starts_match.group(1)

            ends_match = re.search(
                r'ends\s+\d+\s+(\d{4}/\d{2}/\d{2}\s+\d{2}:\d{2}:\d{2})',
                block
            )
            if ends_match:
                lease.ends = ends_match.group(1)

            mac_match = re.search(
                r'hardware\s+ethernet\s+(\S+);',
                block
            )
            if mac_match:
                lease.mac_address = mac_match.group(1)

            hostname_match = re.search(
                r'client-hostname\s+"([^"]+)"',
                block
            )
            if hostname_match:
                lease.hostname = hostname_match.group(1)

            state_match = re.search(
                r'binding\s+state\s+(\S+);',
                block
            )
            if state_match:
                lease.state = state_match.group(1)

            lease_map[ip] = lease

        # Filter active leases
        now = datetime.utcnow()
        for ip, lease in lease_map.items():
            if lease.state == "active":
                # Check if expired
                if lease.ends:
                    try:
                        ends_dt = datetime.strptime(
                            lease.ends, "%Y/%m/%d %H:%M:%S"
                        )
                        if ends_dt < now:
                            lease.state = "expired"
                            continue
                    except ValueError:
                        pass
                leases.append(lease)

        return leases

    def get_leases_for_subnet(
        self, subnet_network: str
    ) -> List[DhcpLeaseInfo]:
        """Get active leases filtered by subnet."""
        all_leases = self.parse_leases()
        try:
            network = ipaddress.IPv4Network(subnet_network, strict=False)
            return [
                lease for lease in all_leases
                if ipaddress.IPv4Address(lease.ip_address) in network
            ]
        except ValueError:
            return all_leases

    # --- Validation Helpers ---

    def validate_ip_in_subnet(
        self, ip: str, network_cidr: str
    ) -> bool:
        """Check if an IP address belongs to a subnet."""
        try:
            network = ipaddress.IPv4Network(network_cidr, strict=False)
            return ipaddress.IPv4Address(ip) in network
        except ValueError:
            return False

    def validate_mac_address(self, mac: str) -> bool:
        """Validate MAC address format."""
        pattern = re.compile(
            r'^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$'
        )
        return bool(pattern.match(mac))

    def validate_ip_range(
        self, start: str, end: str, network_cidr: str
    ) -> tuple:
        """
        Validate IP range is within subnet.
        Returns (is_valid, error_message).
        """
        try:
            network = ipaddress.IPv4Network(network_cidr, strict=False)
            start_ip = ipaddress.IPv4Address(start)
            end_ip = ipaddress.IPv4Address(end)

            if start_ip not in network:
                return False, f"Range start {start} not in subnet {network_cidr}"
            if end_ip not in network:
                return False, f"Range end {end} not in subnet {network_cidr}"
            if start_ip >= end_ip:
                return False, "Range start must be less than range end"

            return True, "Valid"
        except ValueError as e:
            return False, str(e)


# Singleton instance
dhcp_service = DhcpService()
